import torch
from torch import Tensor
from typing import Tuple


def black_scholes(
    p: Tensor,
    k: Tensor,
    r: Tensor,
    m: Tensor,
    sigma: Tensor,
) -> Tuple[Tensor, Tensor, Tensor]:
    """
    Standard Black-Scholes formula for vector arguments.
    Returns tuple of option price, N(d1), and d1.
    """
    assert p.device == k.device == r.device == m.device == sigma.device
    assert p.shape[0] == k.shape[0] == r.shape[0] == m.shape[0] == sigma.shape[0]
    
    sigm = sigma * torch.sqrt(m)
    pvk = k * torch.exp(-r * m)
    d1 = torch.log(p / pvk) / torch.clamp(sigm, min=1e-15) + 0.5 * sigm
    d2 = d1 - sigm
    normcdf = torch.distributions.normal.Normal(0, 1).cdf
    nd1, nd2 = normcdf(d1), normcdf(d2)
    res = p * nd1 - pvk * nd2
    return res, nd1, d1


def gbm(
    p0: Tensor,
    mu: Tensor,
    sigma: Tensor,
    m0: Tensor,
    nt: int,
    rng_seed: int = 12345,
    use_gpu: bool = False
) -> Tuple[Tensor, Tensor, Tensor]:
    """
    Function to simulate geometric brownian motion.
    Returns tuple of price, db, and maturity matricies
    """
    assert p0.device == mu.device == sigma.device == m0.device
    assert p0.shape == mu.shape == sigma.shape == m0.shape
    n = len(p0)
    torch.manual_seed(rng_seed)
    
    orig_t = {'device':p0.device, 'dtype':p0.dtype}
    cast_t = {'device':'cuda' if use_gpu else p0.device, 'dtype':p0.dtype}
    if use_gpu:
        p0, mu, sigma, m0 = p0.cuda(), mu.cuda(), sigma.cuda(), m0.cuda()
    
    dt = m0 / nt
    m = torch.stack([m0x - torch.linspace(0.0, m0x, nt+1).to(**cast_t) for m0x in m0])
    db = torch.diag(torch.sqrt(dt)) @ torch.randn((n, nt), device=('cuda' if use_gpu else dt.device)).to(**cast_t)
    brownian_motion = torch.diag(sigma) @ db
    drift = torch.diag( (mu - 0.5 * sigma**2) * dt ) @ torch.ones(db.shape).to(**cast_t)
    res = torch.hstack([p0.unsqueeze(-1), torch.diag(p0) @ torch.exp(brownian_motion + drift).cumprod(dim=1)])
    return res.to(**orig_t), db.to(**orig_t), m.to(**orig_t)


def black_scholes_mat(
    p: Tensor, # dim: n * (nt+1)
    k: Tensor, # dim: n
    r: Tensor, # dim: n
    m: Tensor, # dim: n * (nt+1)
    sigma: Tensor, # dim: n
) -> Tuple[Tensor, Tensor, Tensor]:
    """
    Black-Scholes formula adapted for matricies p and m
    generated by geometric brownian motion
    """
    assert p.device == k.device == r.device == m.device == sigma.device
    assert p.shape[0] == k.shape[0] == r.shape[0] == m.shape[0] == sigma.shape[0]
    assert p.shape[1] == m.shape[1]
    
    eps = torch.tensor(1e-15)
    ones_like_p = torch.ones(p.shape)
    
    sigm = torch.diag(sigma) @ torch.sqrt(m)
    pvk = torch.diag(k) @ torch.exp(torch.diag(-r) @ m)
    d1 = torch.log(p / pvk) / torch.maximum(sigm, eps) + 0.50 * sigm
    d2 = d1 - sigm
    normcdf = torch.distributions.normal.Normal(0, 1).cdf
    nd1 = normcdf(d1)
    nd2 = normcdf(d2)
    res = p * nd1 - pvk * nd2
    return res, nd1, d1


def black_scholes_2p(
    moneyness: Tensor, # p / pvk
    vol_to_mat: Tensor # sigma * sqrt(m)
) -> Tuple[Tensor, Tensor, Tensor]:
    """
    Standard Black-Scholes formula for vector arguments.
    Returns tuple of option price, N(d1), and d1.
    """
    assert moneyness.device == vol_to_mat.device
    assert moneyness.shape[0] == vol_to_mat.shape[0]
    
    d1 = torch.clamp(torch.log(moneyness), min=-1e15) / torch.clamp(vol_to_mat, min=1e-15) + 0.5 * vol_to_mat
    d2 = d1 - vol_to_mat
    normcdf = torch.distributions.normal.Normal(0, 1).cdf
    nd1, nd2 = normcdf(d1), normcdf(d2)
    res = nd1 - nd2 / moneyness
    return res, nd1, d1

